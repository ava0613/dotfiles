set nocompatible            | " disable compatibility to old-time vi
set encoding=utf-8
syntax on                  |  " syntax highlighting
filetype plugin indent on   | " allow auto-indenting depending on file type
set hidden " allow switching buffers without having to save

"set ruler " bottom line status

set wildmenu
"set wildmode=longest,list  | " get bash-like tab completions
"hihlight WildMenu term=reverse cterm=reverse ctermfg=NONE ctermbg=NONE gui=reverse guifg=NONE guibg=NONE
"highlight WildMenu ctermfg=15 ctermbg=24
if v:version >= 900 " vim 9.0+
    set wildoptions=pum " (only in vim9) vertical popupmenu for options instead of lateral
endif


" indent stuff
set tabstop=4                | " number of columns occupied by a tab 
set softtabstop=4            | " see multiple spaces as tabstops so <BS> does the right thing
set expandtab                | " converts tabs to white space
set autoindent               | " indent a new line the same amount as the line just typed
set shiftwidth=4             | " width for autoindents

"set mouse=v                 | " middle-click paste with 
"set mouse=a                 " enable mouse click
"set clipboard=unnamedplus   " using system clipboard
set ttyfast               |  " Speed up scrolling in Vim
" set spell                 " enable spell check (may need to download language package)
" set noswapfile            " disable creating swap file
" set backupdir=~/.cache/vim " Directory to store backup files.

""let g:airline_left_sep = '»'
""let g:airline_right_sep = '«'



let mapleader = " "
nnoremap <Leader>w :w<CR>
nnoremap <Leader>q :q<CR>
nnoremap <Leader>x :x<CR>  | "write and quit
nnoremap <Leader>c :bd<CR> | "close current buffer, but leave others

nnoremap <Leader>y "+y | "yank to system clipboard, when it works

set paste
nnoremap <Leader>pp :set paste!<CR>         | " toggle paste

"line numbers
"set number                  | " add line numbers
nnoremap <Leader>nn :set number!<CR>         | " toggle line numbers
nnoremap <Leader>nr :set relativenumber!<CR> | "toggle relative line numbers

" search stuff
set ignorecase 
set smartcase 
set incsearch
set hlsearch

"buffers
nnoremap <Leader><Down> :b#<CR>         | "buffer alt-tab
nnoremap <Leader><Right> :bnext<CR>
nnoremap <Leader><Left> :bprevious<CR>
nnoremap <Leader><Up> :ls<CR>           | "list buffers
nnoremap <Leader><Tab> :buffers<CR>     | "list buffers

" vim config stuff
nnoremap <Leader>ve :e $MYVIMRC<CR>       | "load my vimrc
nnoremap <Leader>vs :source $MYVIMRC<CR>  | "source my vimrc
nnoremap <Leader>vn :e $HOME/.config/ava/notes/vim.md<CR>  | "load my vim notes 
colorscheme darkburn
nnoremap <Leader>vvv :colorscheme 
nnoremap <Leader>vva :colorscheme quiet<CR>
nnoremap <Leader>vvw :colorscheme default<CR>
nnoremap <Leader>vve :colorscheme desert<CR>
nnoremap <Leader>vvr :colorscheme torte<CR>
nnoremap <Leader>vvs :colorscheme elflord<CR>
nnoremap <Leader>vvd :colorscheme zenburn<CR>
nnoremap <Leader>vvf :colorscheme darkburn<CR>
nnoremap <Leader>vvx :colorscheme 256-grayvim<CR>
nnoremap <Leader>vvc :colorscheme wombat256<CR>

" visuals
set showmatch                                           | " show matching paranthesis/bracket
nnoremap <Leader>hs :set hlsearch!<CR>                  | " toggle highlight when searching
nnoremap <Leader>hl :set cursorline!<CR>                | " toggle
nnoremap <Leader>hc :set cursorcolumn!<CR>
nnoremap <Leader>hh :set cursorline! cursorcolumn!<CR>  | " toggle both at the same time
nnoremap <silent><leader>hi :execute "set colorcolumn=" . (&colorcolumn == "" ? "80" : "")<CR> | " toggle colorcolumn
set list lcs=trail:·,tab:»·  " show nasty chars, like illegal tabs and trailing spaces
"" ¬ →  ⤦  ↩  
"set list lcs=tab:»·,eol:¬

nnoremap <Leader>ff :EditCwd <Tab>          | " 
nnoremap <Leader>ee :Vexplore<CR>           | " file explorer    
nnoremap <Leader>fd :Lexplore<CR>           | "open netrw in the dir where vim started
nnoremap <leader>fe :Lexplore %:p:h<CR>     | "open netrw in dir of current file

nnoremap <leader>tt g_lD<CR> | "remove trailing spaces from the line

" C-e, C-y  -- scroll without moving cursor
" C-o, C-i -- 

" move around visually selected lines
vnoremap J :m '>+1<CR>gv=gv
vnoremap K :m '<-2<CR>gv=gv

"   vim.keymap.set("v", "J", ":m '>+1<CR>gv=gv")↲
"   vim.keymap.set("v", "K", ":m '<-2<CR>gv=gv")↲
"   ↲
"   -- vim.keymap.set("n", "J", "mzJ`z") -- keep cursor in place when joining lines↲
"   -- keep cursorline centered while scrollig↲
"   vim.keymap.set("n", "<C-d>", "<C-d>zz")↲
"   vim.keymap.set("n", "<C-u>", "<C-u>zz")↲
"   -- keep search terms in the middle while sarching↲
"   vim.keymap.set("n", "n", "nzzzv")↲
"   vim.keymap.set("n", "N", "Nzzzv")↲


" ==============================================================================
" Use ripgrep as the grep program
" --vimgrep: Output matches in Vim's quickfix format (file:line:col:match)
" --no-heading: Don't print headings (cleaner for quickfix)
" --line-number: Always print line numbers (redundant with --vimgrep but harmless)
" --column: Always print column numbers (redundant with --vimgrep but harmless)
" --smart-case: Search case-insensitively unless pattern contains uppercase characters
" --hidden: Include hidden files and directories in search
" --glob '!.git/': Exclude the .git directory (and other common ignores)
" --follow: Follow symlinks
set grepprg=rg\ --vimgrep\ --no-heading\ --line-number\ --column\ --smart-case\ --hidden\ --glob\ '!.git/'\ --follow
" Format for ripgrep --vimgrep output: file:line:col:message
set grepformat=%f:%l:%c:%m

" ==============================================================================
" statusline settings
set laststatus=2
set statusline=
set statusline+=%#StatusLine#
set statusline+=%#CursorColumn#
"set statusline+=%#LineNr#
set statusline+=\%l:%c
"set statusline+=%#PmenuSel#
"set statusline+=\ %#WarningMsg#%{&paste?'PASTE':'NOPASTE'}%#StatusLine#
set statusline+=\ %{&paste?'PASTE':''}
set statusline+=%*
"set statusline+o=%#PmenuSel#
"set statusline+=%#LineNr#
set statusline+=%=
set statusline+=\ %f
set statusline+=%m%R
set statusline+=%=
set statusline+=%#CursorColumn#
"set statusline+=%{GetBufferListString()}
set statusline+=%*
set statusline+=%=
set statusline+=%#CursorColumn#
set statusline+=\ [%p%%%L␤]
set statusline+=\ Ξ%B
set statusline+=\ %y
set statusline+=\ %{&fileencoding?&fileencoding:&encoding}
set statusline+=\[%{&fileformat}\]

nnoremap ll :lnext<cr>
nnoremap lo :lprev<cr>
nnoremap lp :llast<cr>
nnoremap li :lfirst<cr>
nnoremap lk :lolder<cr>
nnoremap l; :lnewer<cr>
nnoremap ly :call ToggleLoclist('vertical')<cr>
nnoremap lh :call ToggleLoclist('')<cr>
nnoremap kk :cnext<cr>
nnoremap ki :cprev<cr>
nnoremap ko :clast<cr>
nnoremap ku :cfirst<cr>
nnoremap kj :colder<cr>
nnoremap kl :cnewer<cr>
nnoremap ky :call ToggleQuickfix('vertical')<cr>
nnoremap kh :call ToggleQuickfix('')<cr>
autocmd QuickFixCmdPost rep* copen
" Function to toggle  quickfix window
function! ToggleLoclist( direction) abort
    if empty(filter(getwininfo(), 'v:val.loclist'))
        if a:direction ==# 'vertical'
           vertical copen
           vertical resize 80
        else
           lopen
        endif
    else
        lclose
    endif
endfunction
function! ToggleQuickfix( direction) abort
    "if !empty(ndbuf(bufnr('[Quickfix List]')))
    "if empty(filter(getwininfo(), 'v:val.quickfix'))
    if empty(filter(getwininfo(), 'v:val.quickfix'))
        if a:direction ==# 'vertical'
           vertical copen
           vertical resize 80
        else
           copen
        endif
    else
        cclose
    endif
endfunction

" ==============================================================================
" Show Open Buffers in the Tabline
set showtabline=2
highlight MyCurrentTabPageBuffer ctermfg=white ctermbg=darkblue 
highlight MyOtherTabPageBuffer ctermfg=gray ctermbg=black 
let g:tabline_highlight_group_1 = 'MyCurrentTabPageBuffer'
let g:tabline_highlight_group_2 = 'MyOtherTabPageBuffer'
" --- MyCustomTabline Function (Corrected) ---
function! MyCustomTabline() abort
    let s = ''
    " CORRECTED LINE: Use tabpagenr() to get the current tabpage number
    let bufnr_list = tabpagebuflist(tabpagenr())
    let current_buf = bufnr('%')

    " Loop through all *listed* buffers (i.e., not help, quickfix, etc.).
    for i in getbufinfo({'buflisted':1})
        let buf_id = i.bufnr
        let buf_name = fnamemodify(i.name, ':t')
        if buf_name == ''
            let buf_name = '[No Name]'
        endif

        " Apply highlight based on whether the buffer is in the current tabpage or another.
        " Ensure bufnr_list is actually a list before using index()
        " (though tabpagebuflist(tabpagenr()) should now reliably return a list)
        if type(bufnr_list) == v:t_list && index(bufnr_list, buf_id) >= 0
            let s .= '%#MyCurrentTabPageBuffer#' " Apply highlight for current tabpage buffer
        else
            let s .= '%#MyOtherTabPageBuffer#'   " Apply highlight for other tabpage buffer
        endif

        " Apply highlight for the currently active buffer (the one with the cursor).
        " This part overrides the previous highlight choice, giving precedence to active buffer status.
        if buf_id == current_buf
            let s .= '%#TabLineSel#'
        else
            let s .= '%#TabLine#'
        endif

        " Make the buffer entry clickable to switch to it.
        " %{buf_id}T is the special format code for this.
        let s .= ' %' . buf_id . 'T'

        " Construct the display name for the buffer.
        let buf_display_name = buf_name
        if i.changed
            let buf_display_name .= ' [+]'
        endif
        " Truncate long names to avoid clutter (adjust 30 as needed).
        if strlen(buf_display_name) > 30
            let buf_display_name = strcharpart(buf_display_name, 0, 27) . '...'
        endif
        let s .= buf_display_name . ' '

        " Reset highlight groups for the next item or end of current item.
        let s .= '%T' " Reset tab highlight (important for clickability).
        let s .= '%*' " Reset custom highlight (back to default).
    endfor

    " Add empty space filler to push subsequent items to the far right.
    let s .= '%='

    return s
endfunction
set tabline=%!MyCustomTabline()

" ==============================================================================
" Custom Command to Edit Files from Current Directory with Wildmenu
function! GetFilesFromCurrentDir(ArgLead, CmdLine, CursorPos)
    let current_buffer_dir = expand('%:h')
    let pattern = current_buffer_dir . '/*'
    return glob(pattern, 0, 1)
endfunction
function! EditFile(filename)
    execute 'edit ' . fnameescape(a:filename)
endfunction
" 'register' EditCwd command 
command! -nargs=1 -complete=customlist,GetFilesFromCurrentDir EditCwd call EditFile(<f-args>)


" ==============================================================================
" Enable persistent undo
set undofile
if !isdirectory(expand('~/.vim/undodir'))
    call mkdir(expand('~/.vim/undodir'), 'p', 0700)
endif
set undodir=~/.vim/undodir
